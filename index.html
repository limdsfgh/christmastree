<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>Downward Pink Christmas Tree with Particle Star</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #020504;
      overflow: hidden;
      font-family: 'Pacifico', cursive;
    }

    /* Three.js 在底层 */
    #three-container {
      position: fixed;
      inset: 0;
      z-index: 0;
    }

    /* Canvas 圣诞树在上层 */
    #tree-canvas {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    /* 氛围暗角 */
    #vignette {
      position: fixed;
      inset: 0;
      z-index: 2;
      background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.85) 100%);
      pointer-events: none;
    }

    /* Merry Christmas 文本自适应 */
    #message,
    #message2 {
      position: fixed;
      bottom: 45%;
      color: #FFB6C1;
      font-size: 5vw;
      text-shadow: 0 0 1vw #FF69B4, 0 0 2vw #FF9ACD;
      z-index: 3;
    }

    #message {
      left: 10vw;
      text-align: left;
    }

    #message2 {
      right: 5vw;
      text-align: right;
    }

    /* 音乐控件隐藏 */
    #audio-control {
      display: none;
    }
  </style>
</head>

<body>
  <div id="three-container"></div>
  <canvas id="tree-canvas"></canvas>
  <div id="vignette"></div>
  <div id="message">Merry</div>
  <div id="message2">Christmas</div>

  <!-- 背景音乐 -->
  <div id="audio-control">
    <audio id="bgm" src="VIDEO_ID.mp3" loop></audio>
  </div>

  <script>
    const bgm = document.getElementById('bgm');
    window.addEventListener('load', () => {
      const playPromise = bgm.play();
      if (playPromise !== undefined) {
        playPromise.catch(() => {
          const cover = document.createElement('div');
          cover.style.position = 'fixed';
          cover.style.inset = '0';
          cover.style.zIndex = '10';
          cover.style.cursor = 'pointer';
          cover.title = '点击播放背景音乐';
          document.body.appendChild(cover);
          cover.addEventListener('click', () => { bgm.play(); cover.remove(); });
        });
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

  <!-- ================= THREE.JS 背景星尘 ================= -->
  <script id="vertexShader" type="x-shader/x-vertex">
   uniform float uTime;
attribute float aSize;
attribute float aOffset;
varying float vOpacity;
varying vec3 vColor;
void main() {
  vColor = color;
  float sparkle = sin(uTime * 1.5 + aOffset) * 0.5 + 0.5;
  vOpacity = 0.2 + sparkle * 0.8;
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  gl_PointSize = aSize * (300.0 / -mvPosition.z) * (0.6 + sparkle * 0.4);
  gl_Position = projectionMatrix * mvPosition;
}
</script>

  <script id="fragmentShader" type="x-shader/x-fragment">
varying float vOpacity;
varying vec3 vColor;
void main() {
  float d = distance(gl_PointCoord, vec2(0.5));
  if (d > 0.5) discard;
  float strength = pow(1.0 - d * 2.0, 2.0);
  gl_FragColor = vec4(vColor, vOpacity * strength);
}
</script>

  <script>
    // ================= THREE.JS 背景星尘 =================
    let scene, camera, renderer, clock;
    const AMBIENT_COUNT = 50000;

    function getAmbientRange() {
      const w = window.innerWidth;
      if (w <= 768) return { x: 120, y: 100, z: 120 };      // 手机
      if (w <= 1024) return { x: 160, y: 130, z: 160 };     // iPad
      return { x: 200, y: 160, z: 200 };                    // 电脑
    }

    let points;
    function initThree() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 40;
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById("three-container").appendChild(renderer.domElement);

      clock = new THREE.Clock();
      createAmbientGeometry();
      animateThree();
    }

    function createAmbientGeometry() {
      const geo = new THREE.BufferGeometry();
      const pos = [], col = [], size = [], off = [];
      const range = getAmbientRange();

      for (let i = 0; i < AMBIENT_COUNT; i++) {
        pos.push(
          (Math.random() - 0.5) * range.x,
          (Math.random() - 0.5) * range.y,
          (Math.random() - 0.5) * range.z
        );
        const r = 0.9 + Math.random() * 0.1;
        const g = 0.4 + Math.random() * 0.2;
        const b = 0.6 + Math.random() * 0.2;
        col.push(r, g, b);
        size.push(Math.random() * 1.5 + 0.5);
        off.push(Math.random() * Math.PI * 2);
      }

      geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
      geo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));
      geo.setAttribute("aSize", new THREE.Float32BufferAttribute(size, 1));
      geo.setAttribute("aOffset", new THREE.Float32BufferAttribute(off, 1));

      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: document.getElementById("vertexShader").textContent,
        fragmentShader: document.getElementById("fragmentShader").textContent,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        vertexColors: true
      });

      if (points) scene.remove(points); // 移除旧点
      points = new THREE.Points(geo, mat);
      scene.add(points);
    }

    function animateThree() {
      requestAnimationFrame(animateThree);
      scene.children.forEach(o => {
        if (o.material && o.material.uniforms) o.material.uniforms.uTime.value = clock.getElapsedTime();
        o.rotation.y += 0.0008;
      });
      renderer.render(scene, camera);
    }

    // 调整大小重新生成背景星尘
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      createAmbientGeometry(); // 重新生成
    });

    initThree();
  </script>

  <!-- ================= 圣诞树粒子部分不动 ================= -->
  <script>
    const canvas = document.getElementById("tree-canvas");
    const ctx = canvas.getContext("2d");
    let treeParticles = [], topStar;

    class Particle {
      constructor(x, y, r, c) {
        this.x = x; this.y = y; this.r = r; this.c = c; this.a = 0;
        this.radius = Math.random() * 2 + 1; this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.01 + Math.random() * 0.01;
      }
      update() { this.a = Math.min(this.a + 0.02, 1); }
      draw() {
        this.angle += this.speed;
        const x = this.x + Math.cos(this.angle) * this.radius;
        const y = this.y + Math.sin(this.angle) * this.radius;
        ctx.save(); ctx.globalAlpha = this.a; ctx.shadowBlur = 14; ctx.shadowColor = this.c;
        ctx.fillStyle = this.c; ctx.beginPath(); ctx.arc(x, y, this.r, 0, Math.PI * 2); ctx.fill(); ctx.restore();
      }
    }

    class ParticleStar {
      constructor(x, y, size, count) {
        this.x = x; this.y = y; this.size = size; this.count = count; this.particles = [];
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const angle = t * Math.PI * 2 * 2;
          const radius = Math.sin(5 * angle) * size * (0.8 + Math.random() * 0.4);
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          this.particles.push(new Particle(px, py, Math.random() * 1.5 + 0.5, "#FF69B4"));
        }
      }
      update() { this.particles.forEach(p => p.update()); }
      draw() { this.particles.forEach(p => p.draw()); }
    }

    function createTree() {
      treeParticles.length = 0;
      const layers = 20;
      const baseWidth = canvas.width * 0.5;
      const topWidth = canvas.width * 0.06;
      const treeHeight = canvas.height * 0.75;
      const baseY = canvas.height * 0.88;
      const particlesTotal = 2500;

      for (let l = 0; l < layers; l++) {
        const t = l / (layers - 1);
        const yTop = baseY - t * treeHeight;
        const layerHeight = treeHeight / layers;
        const yBottom = yTop + layerHeight * (0.7 + Math.random() * 0.3);
        const layerWidth = topWidth + (baseWidth - topWidth) * (1 - t);
        const particlesPerLayer = Math.floor(particlesTotal / layers);
        for (let i = 0; i < particlesPerLayer; i++) {
          const x = canvas.width / 2 + (Math.random() - 0.5) * layerWidth * (t > 0.05 ? 1 : 0.1);
          const downward = t * 50 * Math.random();
          const y = yTop + Math.pow(Math.random(), 0.6) * (yBottom - yTop) + downward;
          const r = Math.random();
          let c; if (r > 0.9) c = "#FFD1DC"; else if (r > 0.75) c = "#FF9ACD"; else c = "#FF69B4";
          const radius = (Math.random() * 2 + 1) * (canvas.width / 1920);
          treeParticles.push(new Particle(x, y, radius, c));
        }
      }
      topStar = new ParticleStar(canvas.width / 2, canvas.height * 0.12, Math.max(canvas.width, canvas.height) * 0.015, 100);
    }

    function animateTree() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      treeParticles.forEach(p => { p.update(); p.draw(); });
      topStar.update(); topStar.draw();
      requestAnimationFrame(animateTree);
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth; canvas.height = window.innerHeight;
      createTree();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    animateTree();
  </script>

</body>

</html>